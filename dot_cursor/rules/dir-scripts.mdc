---
name: 'Scripts'
description: 'Utility scripts - standalone, self-documenting'
globs: ["**/scripts/**/*", "**/bin/**/*", "**/tools/**/*"]
alwaysApply: false
---

# Script Guidelines

Rules for utility scripts. Inherits from `always.md` and `etiquette.md`.

## Core Principles

1. **Standalone** - No hidden dependencies
2. **Self-documenting** - Clear --help output
3. **Fail loudly** - Exit codes and error messages
4. **Idempotent** - Safe to run multiple times

## Argument Parsing

```python
import argparse

def main():
    parser = argparse.ArgumentParser(
        description="What this script does"
    )
    parser.add_argument("input", help="Input file path")
    parser.add_argument("-o", "--output", default="out.txt",
                        help="Output path (default: out.txt)")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Enable verbose output")
    args = parser.parse_args()
    
    # Script logic here

if __name__ == "__main__":
    main()
```

## Exit Codes

```python
import sys

# Success
sys.exit(0)

# General error
sys.exit(1)

# Misuse (bad args)
sys.exit(2)
```

## Logging

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

logger.info("Processing %s", filename)
logger.error("Failed: %s", error)
```

## Best Practices

- Shebang line: `#!/usr/bin/env python3`
- Docstring at top explaining purpose
- Progress indicators for long operations
- Confirm destructive actions

## Never Do

- Hardcode paths (use arguments or env vars)
- Silently fail (always log/exit with status)
- Require interactive input without --yes flag
- Leave print debugging in production scripts
